To tackle the problem of extracting arguments from the input file and then processing them, we can break it down into two main functions. The first function will read the input and extract the arguments. The second function will process these arguments to generate the required tree information.

Let's start by writing the function to extract arguments from the input file.

### Extract Arguments Function

```python
def extract_arguments(fh):
    n = int(fh.readline().strip())
    nodes = []
    for _ in range(n):
        node_info = list(map(int, fh.readline().strip().split()))
        nodes.append(node_info)
    return n, nodes

if __name__ == "__main__":
    import sys
    input_path = sys.argv[1]
    with open(input_path, 'r') as fh:
        n, nodes = extract_arguments(fh)
    # Use the extracted arguments to call the process function
    process_tree(n, nodes)
```

Now let's move on to writing the function that processes the arguments to generate the required information about each node in the binary tree.

### Process Tree Function

```python
def process_tree(n, nodes):
    from collections import defaultdict, deque
    
    tree = {i: {"left": -1, "right": -1, "parent": -1, "depth": -1, "height": -1, "type": None} for i in range(n)}
    
    for node_id, left, right in nodes:
        tree[node_id]["left"] = left
        tree[node_id]["right"] = right
        if left != -1:
            tree[left]["parent"] = node_id
        if right != -1:
            tree[right]["parent"] = node_id
    
    root = next(node_id for node_id, info in tree.items() if info["parent"] == -1)
    
    def set_depths(node_id, depth):
        tree[node_id]["depth"] = depth
        if tree[node_id]["left"] != -1:
            set_depths(tree[node_id]["left"], depth + 1)
        if tree[node_id]["right"] != -1:
            set_depths(tree[node_id]["right"], depth + 1)
    
    def calculate_height(node_id):
        if node_id == -1:
            return -1
        left_height = calculate_height(tree[node_id]["left"])
        right_height = calculate_height(tree[node_id]["right"])
        tree[node_id]["height"] = 1 + max(left_height, right_height)
        return tree[node_id]["height"]
    
    set_depths(root, 0)
    calculate_height(root)
    
    for node_id in sorted(tree.keys()):
        info = tree[node_id]
        degree = (info["left"] != -1) + (info["right"] != -1)
        parent = info["parent"]
        sibling = -1
        if parent != -1:
            if tree[parent]["left"] == node_id:
                sibling = tree[parent]["right"]
            else:
                sibling = tree[parent]["left"]
        
        if parent == -1:
            node_type = "root"
        elif degree == 0:
            node_type = "leaf"
        else:
            node_type = "internal node"
        
        print(f"node {node_id}: parent = {parent}, sibling = {sibling}, degree = {degree}, depth = {info['depth']}, height = {info['height']}, {node_type}")

if __name__ == "__main__":
    import sys
    input_path = sys.argv[1]
    with open(input_path, 'r') as fh:
        n, nodes = extract_arguments(fh)
    process_tree(n, nodes)
```

### Explanation:

1. **Extract Arguments Function**:
   - Reads the number of nodes `n`.
   - Reads the `n` lines representing each node's information and stores it in a list of tuples.

2. **Process Tree Function**:
   - Initializes a dictionary `tree` to store detailed information about each node.
   - Fills the tree information with parent-child relationships.
   - Identifies the root node (the one with no parent).
   - Sets the depth of each node using a recursive function `set_depths`.
   - Calculates the height of each node using a recursive function `calculate_height`.
   - Iterates over each node to determine its degree, sibling, and type.
   - Prints the required information in the specified format.

To run this script, you need to provide an input file path via command line arguments. The script reads the input file, extracts the arguments, processes the tree, and prints the required information.